diff --git a/node_modules/avrgirl-arduino/avrgirl-arduino.js b/node_modules/avrgirl-arduino/avrgirl-arduino.js
index 96f0906..26df0d8 100644
--- a/node_modules/avrgirl-arduino/avrgirl-arduino.js
+++ b/node_modules/avrgirl-arduino/avrgirl-arduino.js
@@ -15,6 +15,7 @@ var injectDependencies = function(boards, Connection, protocols) {
       megaDebug: opts.megaDebug || false,
       board: opts.board || 'uno',
       port: opts.port || '',
+      serialPort: opts.serialPort || null,
       manualReset: opts.manualReset || false,
       disableVerify: opts.disableVerify || false
     };
diff --git a/node_modules/avrgirl-arduino/dist/avrgirl-arduino.global.js b/node_modules/avrgirl-arduino/dist/avrgirl-arduino.global.js
index 78e4504..be65d65 100644
--- a/node_modules/avrgirl-arduino/dist/avrgirl-arduino.global.js
+++ b/node_modules/avrgirl-arduino/dist/avrgirl-arduino.global.js
@@ -36,6 +36,7 @@ var injectDependencies = function(boards, Connection, protocols) {
       megaDebug: opts.megaDebug || false,
       board: opts.board || 'uno',
       port: opts.port || '',
+      serialPort: opts.serialPort || null,
       manualReset: opts.manualReset || false,
       disableVerify: opts.disableVerify || false
     };
diff --git a/node_modules/avrgirl-arduino/dist/avrgirl-arduino.js b/node_modules/avrgirl-arduino/dist/avrgirl-arduino.js
index 1834a95..6de6fed 100644
--- a/node_modules/avrgirl-arduino/dist/avrgirl-arduino.js
+++ b/node_modules/avrgirl-arduino/dist/avrgirl-arduino.js
@@ -45,6 +45,7 @@ var injectDependencies = function(boards, Connection, protocols) {
       megaDebug: opts.megaDebug || false,
       board: opts.board || 'uno',
       port: opts.port || '',
+      serialPort: opts.serialPort || null,
       manualReset: opts.manualReset || false,
       disableVerify: opts.disableVerify || false
     };
@@ -663,9 +664,14 @@ class SerialPort extends EventEmitter {
     this.browser = true;
     this.path = this.options.path;
     this.isOpen = false;
-    this.port = null;
+    this.port = port || null;
     this.writer = null;
     this.reader = null;
+    this.isUpdating = false;
+    this.pausePromise = Promise.resolve();
+    this.pauseResolve = () => {};
+    this.closeReadPromise = null;
+    this.closeReadResolve = () => {};
     this.baudRate = this.options.baudRate;
     this.requestOptions = this.options.requestOptions || {};
 
@@ -678,45 +684,75 @@ class SerialPort extends EventEmitter {
       .catch((error) => {if (callback) {return callback(error)}}); 
   }
 
+  async _getPort() {
+    if (this.port && !this.options.forceRequest) return this.port;
+    return window.navigator.serial.requestPort(this.requestOptions)
+  }
+
   open(callback) {
-    window.navigator.serial.requestPort(this.requestOptions)
-      .then(serialPort => {
-        this.port = serialPort;
-        if (this.isOpen) return;
-        return this.port.open({ baudRate: this.baudRate || 57600 });
-      })
-      .then(() => this.writer = this.port.writable.getWriter())
-      .then(() => this.reader = this.port.readable.getReader())
-      .then(async () => {
-        this.emit('open');
-        this.isOpen = true;
-        callback(null);
-        while (this.port.readable.locked) {
-          try {
-            const { value, done } = await this.reader.read();
-            if (done) {
-              break;
+    return new Promise((resolve, reject) => {
+      this._getPort()
+        .then(serialPort => {
+          this.port = serialPort;
+          console.log("port: ", this.port);
+          if (this.isOpen) return;
+          return this.port.open({ baudRate: this.baudRate || 57600 });
+        })
+        .then(() => this.writer = this.port.writable.getWriter())
+        .then(() => this.reader = this.port.readable.getReader())
+        .then(async () => {
+          if (!this.isUpdating) this.emit('open');
+          this.isOpen = true;
+          if (callback) callback(null);
+          resolve(null);
+          while (this.port.readable.locked) {
+            try {
+              await this.pausePromise;
+              const { value, done } = await this.reader.read();
+              if (done || this.closeReadPromise) {
+                break;
+              }
+              this.emit('data', Buffer.from(value));
+            } catch (e) {
+              console.error(e);
             }
-            this.emit('data', Buffer.from(value));
-          } catch (e) {
-            console.error(e);
           }
-        }
-      })
-      .catch(error => {callback(error)});
+          this.closeReadResolve();
+        })
+        .catch(error => {
+          if (callback) callback(error);
+          reject(error);
+        });
+    });
   }
 
   async close(callback) {
+    if (!this.isOpen) {
+      if (callback) callback(null);
+      return;
+    }
+    if (this.port.readable.locked) {
+      this.closeReadPromise = new Promise((resolve) => {
+        this.closeReadResolve = resolve;
+      });
+      this.pauseResolve();
+      try {
+        await this.reader.cancel();
+      } catch (err) { console.error(err); }
+      await this.closeReadPromise;
+      this.closeReadPromise = null;
+    }
     try {
       await this.reader.releaseLock();
       await this.writer.releaseLock();
       await this.port.close();
+      if (!this.isUpdating) this.emit('close');
       this.isOpen = false;
     } catch (error) {
       if (callback) return callback(error);
       throw error;
     }
-    callback && callback(null);
+    if (callback) callback(null);
   }
 
   async set(props = {}, callback) {
@@ -741,6 +777,27 @@ class SerialPort extends EventEmitter {
     if (callback) return callback(null);
   }
 
+  async get(callback) {
+    const props = {};
+    try {
+      const signals = await this.port.getSignals();
+      if (Object.prototype.hasOwnProperty.call(signals, 'dataCarrierDetect')) {
+        props.dcd = signals.dataCarrierDetect;
+      }
+      if (Object.prototype.hasOwnProperty.call(signals, 'clearToSend')) {
+        props.cts = signals.clearToSend;
+      }
+      if (Object.prototype.hasOwnProperty.call(signals, 'dataSetReady')) {
+        props.dsr = signals.dataSetReady;
+      }
+    } catch (error) {
+      if (callback) return callback(error);
+      throw error;
+    }
+    if (callback) return callback(props);
+    return props;
+  }
+
   write(buffer, callback) {
     this.writer.write(buffer);
     if (callback) return callback(null);
@@ -757,6 +814,40 @@ class SerialPort extends EventEmitter {
     if (callback) callback(null, buffer);
   }
 
+  async update (options, callback) {
+    try {
+      if (
+        Object.prototype.hasOwnProperty.call(options, 'baudRate')
+        && this.baudRate !== options.baudRate
+      ) {
+        if (this.isOpen) {
+          // try to quietly close then open the port with the new baudRate
+          this.isUpdating = true;
+          await this.close();
+          this.baudRate = options.baudRate;
+          await this.open();
+          this.isUpdating = false;
+        } else {
+          this.baudRate = options.baudRate;
+        }
+      }
+    } catch (error) {
+      if (callback) return callback(error);
+      throw error;
+    }
+    if (callback) callback(null);
+  }
+
+  pause() {
+    this.pausePromise = new Promise((resolve) => {
+      this.pauseResolve = resolve;
+    });
+  }
+
+  resume() {
+    this.pauseResolve();
+  }
+
   // TODO: is this correct?
   flush(callback) {
     //this.port.flush(); // is this sync or a promise?
@@ -807,14 +898,21 @@ Connection.prototype._init = function(callback) {
  * Create new serialport instance for the Arduino board, but do not immediately connect.
  */
 Connection.prototype._setUpSerial = function(callback) {
-  this.serialPort = new Serialport('', {
-    baudRate: this.board.baud,
-    autoOpen: false
-  });
-  this.serialPort.on('open', function() {
-    //    _this.emit('connection:open');
-  })
-  return callback(null);
+  if (this.options.serialPort) {
+    this.serialPort = this.options.serialPort;
+    this.serialPort.update({ baudRate: this.board.baud }, function(error) {
+      return callback(error);
+    });
+  } else {
+    this.serialPort = new Serialport(this.options.port, {
+      baudRate: this.board.baud,
+      autoOpen: false
+    });
+    this.serialPort.on('open', function() {
+      //    _this.emit('connection:open');
+    })
+    return callback(null);
+  }
 };
 
 /**
diff --git a/node_modules/avrgirl-arduino/lib/browser-serialport.js b/node_modules/avrgirl-arduino/lib/browser-serialport.js
index 4483dd1..5b7fa78 100644
--- a/node_modules/avrgirl-arduino/lib/browser-serialport.js
+++ b/node_modules/avrgirl-arduino/lib/browser-serialport.js
@@ -9,9 +9,14 @@ class SerialPort extends EventEmitter {
     this.browser = true;
     this.path = this.options.path;
     this.isOpen = false;
-    this.port = null;
+    this.port = port || null;
     this.writer = null;
     this.reader = null;
+    this.isUpdating = false;
+    this.pausePromise = Promise.resolve();
+    this.pauseResolve = () => {};
+    this.closeReadPromise = null;
+    this.closeReadResolve = () => {};
     this.baudRate = this.options.baudRate;
     this.requestOptions = this.options.requestOptions || {};
 
@@ -24,45 +29,75 @@ class SerialPort extends EventEmitter {
       .catch((error) => {if (callback) {return callback(error)}}); 
   }
 
+  async _getPort() {
+    if (this.port && !this.options.forceRequest) return this.port;
+    return window.navigator.serial.requestPort(this.requestOptions)
+  }
+
   open(callback) {
-    window.navigator.serial.requestPort(this.requestOptions)
-      .then(serialPort => {
-        this.port = serialPort;
-        if (this.isOpen) return;
-        return this.port.open({ baudRate: this.baudRate || 57600 });
-      })
-      .then(() => this.writer = this.port.writable.getWriter())
-      .then(() => this.reader = this.port.readable.getReader())
-      .then(async () => {
-        this.emit('open');
-        this.isOpen = true;
-        callback(null);
-        while (this.port.readable.locked) {
-          try {
-            const { value, done } = await this.reader.read();
-            if (done) {
-              break;
+    return new Promise((resolve, reject) => {
+      this._getPort()
+        .then(serialPort => {
+          this.port = serialPort;
+          console.log("port: ", this.port);
+          if (this.isOpen) return;
+          return this.port.open({ baudRate: this.baudRate || 57600 });
+        })
+        .then(() => this.writer = this.port.writable.getWriter())
+        .then(() => this.reader = this.port.readable.getReader())
+        .then(async () => {
+          if (!this.isUpdating) this.emit('open');
+          this.isOpen = true;
+          if (callback) callback(null);
+          resolve(null);
+          while (this.port.readable.locked) {
+            try {
+              await this.pausePromise;
+              const { value, done } = await this.reader.read();
+              if (done || this.closeReadPromise) {
+                break;
+              }
+              this.emit('data', Buffer.from(value));
+            } catch (e) {
+              console.error(e);
             }
-            this.emit('data', Buffer.from(value));
-          } catch (e) {
-            console.error(e);
           }
-        }
-      })
-      .catch(error => {callback(error)});
+          this.closeReadResolve();
+        })
+        .catch(error => {
+          if (callback) callback(error);
+          reject(error);
+        });
+    });
   }
 
   async close(callback) {
+    if (!this.isOpen) {
+      if (callback) callback(null);
+      return;
+    }
+    if (this.port.readable.locked) {
+      this.closeReadPromise = new Promise((resolve) => {
+        this.closeReadResolve = resolve;
+      });
+      this.pauseResolve();
+      try {
+        await this.reader.cancel();
+      } catch (err) { console.error(err); }
+      await this.closeReadPromise;
+      this.closeReadPromise = null;
+    }
     try {
       await this.reader.releaseLock();
       await this.writer.releaseLock();
       await this.port.close();
+      if (!this.isUpdating) this.emit('close');
       this.isOpen = false;
     } catch (error) {
       if (callback) return callback(error);
       throw error;
     }
-    callback && callback(null);
+    if (callback) callback(null);
   }
 
   async set(props = {}, callback) {
@@ -87,6 +122,27 @@ class SerialPort extends EventEmitter {
     if (callback) return callback(null);
   }
 
+  async get(callback) {
+    const props = {};
+    try {
+      const signals = await this.port.getSignals();
+      if (Object.prototype.hasOwnProperty.call(signals, 'dataCarrierDetect')) {
+        props.dcd = signals.dataCarrierDetect;
+      }
+      if (Object.prototype.hasOwnProperty.call(signals, 'clearToSend')) {
+        props.cts = signals.clearToSend;
+      }
+      if (Object.prototype.hasOwnProperty.call(signals, 'dataSetReady')) {
+        props.dsr = signals.dataSetReady;
+      }
+    } catch (error) {
+      if (callback) return callback(error);
+      throw error;
+    }
+    if (callback) return callback(props);
+    return props;
+  }
+
   write(buffer, callback) {
     this.writer.write(buffer);
     if (callback) return callback(null);
@@ -103,6 +159,40 @@ class SerialPort extends EventEmitter {
     if (callback) callback(null, buffer);
   }
 
+  async update (options, callback) {
+    try {
+      if (
+        Object.prototype.hasOwnProperty.call(options, 'baudRate')
+        && this.baudRate !== options.baudRate
+      ) {
+        if (this.isOpen) {
+          // try to quietly close then open the port with the new baudRate
+          this.isUpdating = true;
+          await this.close();
+          this.baudRate = options.baudRate;
+          await this.open();
+          this.isUpdating = false;
+        } else {
+          this.baudRate = options.baudRate;
+        }
+      }
+    } catch (error) {
+      if (callback) return callback(error);
+      throw error;
+    }
+    if (callback) callback(null);
+  }
+
+  pause() {
+    this.pausePromise = new Promise((resolve) => {
+      this.pauseResolve = resolve;
+    });
+  }
+
+  resume() {
+    this.pauseResolve();
+  }
+
   // TODO: is this correct?
   flush(callback) {
     //this.port.flush(); // is this sync or a promise?
diff --git a/node_modules/avrgirl-arduino/lib/connection-browser.js b/node_modules/avrgirl-arduino/lib/connection-browser.js
index 093e8e1..913a26f 100644
--- a/node_modules/avrgirl-arduino/lib/connection-browser.js
+++ b/node_modules/avrgirl-arduino/lib/connection-browser.js
@@ -25,14 +25,21 @@ Connection.prototype._init = function(callback) {
  * Create new serialport instance for the Arduino board, but do not immediately connect.
  */
 Connection.prototype._setUpSerial = function(callback) {
-  this.serialPort = new Serialport('', {
-    baudRate: this.board.baud,
-    autoOpen: false
-  });
-  this.serialPort.on('open', function() {
-    //    _this.emit('connection:open');
-  })
-  return callback(null);
+  if (this.options.serialPort) {
+    this.serialPort = this.options.serialPort;
+    this.serialPort.update({ baudRate: this.board.baud }, function(error) {
+      return callback(error);
+    });
+  } else {
+    this.serialPort = new Serialport(this.options.port, {
+      baudRate: this.board.baud,
+      autoOpen: false
+    });
+    this.serialPort.on('open', function() {
+      //    _this.emit('connection:open');
+    })
+    return callback(null);
+  }
 };
 
 /**
